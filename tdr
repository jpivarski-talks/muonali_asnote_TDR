#!/usr/bin/env perl

#############################################################################
#
# Perl script to build the TDR, cleanup, and so on.
#
# For help, type:
#
# > tdr help
#
# Created: Lucas Taylor 6 Jan 2005
# Revised: Lucas Taylor 7 Dec 2006 : Added support for mtcc
# Revised: George Alverson 9 Nov 2005
# Revised: Lucas Taylor 17 Jul 2006 : Added support for slhc-eoi
# Revised: Lucas Taylor 20 Jul 2006 : Added diffractive LoI
# Revised: Lucas Taylor 16 Oct 2006 : Added heavy ion TDR
# Revised: George Alverson 21 Dec 2006 : Modified to handle notes
#
#

#############################################################################


use Getopt::Long qw(:config require_order); # the require order means that for
# "tdr command -switch", -switch is passed in ARGV
use File::Basename; # access to directory, filename and extension of script
use File::Copy;
use File::Spec::Functions; # catfile
use File::Find;
use File::Temp qw/ tempfile tempdir /;
use Cwd; # like Unix pwd but more portable
use Cwd 'abs_path';
use File::Glob 'bsd_glob';
use Text::Balanced qw (extract_bracketed);


#############################################################################
# Main:
#############################################################################

my $VERSION = sprintf "%d.%03d", q$Revision: 1.60 $ =~ /(\d+)/g;

my $verbose = '';
my $help = '';
my $style = 'tdr';
my $export = '';
my $draft = 1;
my $wrap = 0;
my $upload = '';
my $reload = '';
my $tmpclean = 1;
my $arxiv = 0;
my $preview = 0;
GetOptions ('verbose!' => \$verbose, # negatable: --noverbose, turn on TeX screen output
            'help|?' => \$help, # echo basic operations and options
            'style=s' => \$style, # tdr/note/an/as/cr/in/paper
            'export!' => \$export, # generate an exportable tarball
            'draft!' => \$draft, # indicate draft status: currently only pas
            'wrap!' => \$wrap, # generate an archive of pdf+figures: currently only pas
            'arxiv!' => \$arxiv, # generate arxiv-specific tarball: currently only pas
            'preview!' => \$preview, # preview the upload to CDS: currently only pas,
            'upload!' => \$upload, # upload pdf+figures to CDS: currently only pas,
            'reload=i' => \$reload, # re-upload. needs id of originally uploaded doc.
            'clean!' => \$tmpclean # clean tmp area of all files
            );

my $n_args = @ARGV; # number of elements in argument list, @ARGV

if ($help || substr($ARGV[0],0,1) eq 'h')
{
    &print_usage();
    exit;
}

if ($reload) {$upload = 1;} # reload implies upload
if ($upload) { $wrap = $upload; } # upload implies wrap
if ($preview) { $wrap = $preview; } # preview implies wrap
if ($style eq "as") { $style = 'pas';}
if ($style eq "paper") { $style = 'cmspaper'; }

if ($n_args == 0)
{ print "\n***** No arguments specified *****\n\n";
     die "For more details type> tdr help\n\n";
}
elsif ($n_args > 3)
{
    print "\n***** Too many arguments specified *****\n\n";
     die "For more details type> tdr help\n\n";
}

&init();

my $arg1 = $ARGV[0]; # array @ARGV contains input arguments
my $arg2 = $ARGV[1];
my $arg3 = $ARGV[2];

if ($arg1 eq "build" || $arg1 eq "b") { &build ( $arg2, $arg3 );}
elsif ($arg1 eq "clean" || $arg1 eq "c") { &clean ( );}
elsif ($arg1 eq "runtime" || $arg1 eq "r") { &runtime ( $arg2 );}
elsif ($arg1 eq "test") { &test ( $arg2 );}
elsif ($arg1 eq "veryclean" || $arg1 eq "v") { &veryclean ();}
else{ # Whatever arguments were typed, they don't make sense...
       print "\n ***** Invalid arguments ***** \n\n";
       die "For more details type> tdr help\n\n";
    }





#############################################################################
# Subroutines:
#############################################################################


#############################################################################
sub print_usage {
    print "******************************************************************************\n";
    print "*                        tdr (version $VERSION)                                 *\n"; #reserve space for the full $VERSION expansion
    print "*                                                                            *\n";
    print "* Builds TDRs and others such documents Lucas Taylor, 6 Jan 2005             *\n";
    print "*                                                                            *\n";
    print "* Initialisation (once per session/new shell)                                *\n";
    print "* --------------                                                             *\n";
    print "* > eval `tdr runtime -sh` // for Bourne-shell or Korn shell                 *\n";
    print "* > eval `tdr runtime -csh` // for c-shell or tc shell                       *\n";
    print "*                                                                            *\n";
    print "* Usage:                                                                     *\n";
    print "* -----                                                                      *\n";
    print "* > tdr [options] build target // process target.tex to produce pdf, etc.    *\n";
    print "*                                                                            *\n";
    print "* target = [ blank ] // builds user guide, use --style=note                  *\n";
    print "*       Example targets: ctdr // Computing TDR                               *\n";
    print "*       ptdr1|ptrd2 // Physics TDR Vol I|II                                  *\n";
    print "*       slhc-eoi // SLHC Expression of Interest                              *\n";
    print "*       mtcc // Magnet test and Cosmic Challenge document                    *\n";
    print "*       foo // builds any file foo.tex in current directory.                 *\n";
    print "* -----                                                                      *\n";
    print "* options:                                                                   *\n";
    print "*    --verbose: log messages from TeX                                        *\n";
    print "*              (default is --noverbose)                                      *\n";
    print "*    --style=: document style, one of tdr/note/an/pas/cr/in/paper            *\n";
    print "*              (default --style=tdr)                                         *\n";
    print "*    --export: create a copy of the entire target for export.                *\n";
    print "*              produces a compressed tarball under Unix.                     *\n";
    print "*              (default --noexport)                                          *\n";
    print "*    --draft:  mark the output as a draft version                            *\n";
    print "*              (default --draft; override with --nodraft)                    *\n";
    print "*    --clean:  clean the tmp working area before execution                   *\n";
    print "*              (default --clean; override with --noclean)                    *\n";
    print "* > tdr clean // deletes temporary output files                              *\n";
    print "* > tdr veryclean // normal clean and also emacs backups etc.                *\n";
    print "* > tdr help // display this help                                            *\n";
    print "*                                                                            *\n";
    print "******************************************************************************\n";
    print "*   PAS specific administrative options:                                     *\n";
    print "*    --wrap:   produce an archive containing output pdf+copies of figs       *\n";
    print "*              in the output directory                                       *\n";
    print "*              (default --nowrap)                                            *\n";
    print "*    --preview: preview the upload to CDS (implies --wrap)                   *\n";
    print "*                                                                            *\n";
    print "*    --upload: upload the pdf+copies of figs to CDS (implies --wrap)         *\n";
    print "*                                                                            *\n";
    print "*    --reload=: CDS document number to reupload (implies --upload)           *\n";
    print "*                                                                            *\n";
    print "******************************************************************************\n";
}



#############################################################################
sub init {
#
# Define various input and output directories
#
    if ($^O eq "MSWin32") {
      $cur_dir = abs_path(cwd());
      $bin_dir = abs_path(dirname($0));
      $top_dir = $bin_dir;
      $gen_dir = $top_dir."/general";
      $tmp_dir = $top_dir."/tmp";
      }
    else {
      $cur_dir = &full_path(&cwd()); # Current directory
      $bin_dir = &full_path(dirname($0)); # Directory containing this script
      $top_dir = &full_path($bin_dir); # Top level of checkout area - this is where the script is
      $gen_dir = &full_path($top_dir."/general"); # Dir. of document skeleton/style
      $tmp_dir = &full_path($top_dir."/tmp"); # Dir. of temp output, dvi/PS files, etc.
      }

}




#############################################################################
sub build {
#
# Build {$target}.tex
#
    if ($tmpclean) {&clean()};
#
# Take target in this order: (1) command line, (2) environment (3) hardwired default
#
    my $n_args = @ARGV; # number of elements in argument list, @ARGV

    $ps = ":"; # path separator symbol: this is now a global symbol
    $ds = "/"; # directory separator
    if ($^O eq "MSWin32") {$ps = ";"; $ds = "\\";} # use ; for Windows

    my $target = $_[0] || $ENV{TDR_TARGET} || "notes_for_authors";
    substr($target,0,1) ne '-' or die "Options ($_[0]) must now go before the command. Sorry.\n";
    $target =~ s/\.tex$//;

# Find the target tex file to be built
    my $target_tex = "$target".'.tex';

    if ($style !~ 'tdr') #must be a note of some sort
    {
    # we search for a file  of the same name starting from the current directory
        my @dirs = ();
        find(sub {
            if ($_ =~ /^$target_tex$/) {
                push(@dirs,$File::Find::dir);
            }
        }, $cur_dir);
        my $nfound = @dirs;
        if ( $nfound != 1 )
        {
          # try restricting the search
          if ( $style =~ 'cmspaper' )
          {
            @dirs = grep (/papers/,@dirs);
          }
          else
          {
            # this only works if checked out in canonical fashion,
            # but it is currently only a fallback anyway
            @dirs = grep (/notes\/notes/,@dirs);
          }
          # regress
         $nfound = @dirs;
         if ( $nfound != 1 )
         {
          print "found no or too many ($nfound) matches for $target_tex starting from $cur_dir\n";
          map { print "$_\n" } @dirs;
          die "Please fix this.\n";
         }
        }
        $tex_dir = $dirs[0];
    }
    else
    {


# Look in some sensible places (yeah, this is not elegant but it's clear and it works)
        if ( -e "$cur_dir/$target_tex") { $tex_dir = "$cur_dir"; }
        elsif( -e "$top_dir/general/$target_tex") { $tex_dir = "$top_dir/general"; }
        elsif( -e "$top_dir/ctdr/tex/$target_tex") { $tex_dir = "$top_dir/ctdr/tex"; }
        elsif( -e "$top_dir/ptdr1/tex/$target_tex") { $tex_dir = "$top_dir/ptdr1/tex"; }
        elsif( -e "$top_dir/ptdr2/tex/$target_tex") { $tex_dir = "$top_dir/ptdr2/tex"; }
        elsif( -e "$top_dir/slhc-eoi/tex/$target_tex") { $tex_dir = "$top_dir/slhc-eoi/tex"; }
        elsif( -e "$top_dir/mtcc/tex/$target_tex") { $tex_dir = "$top_dir/mtcc/tex"; }
        elsif( -e "$top_dir/diffractive/tex/$target_tex") { $tex_dir = "$top_dir/diffractive/tex"; }
        elsif( -e "$top_dir/hitdr/tex/$target_tex") { $tex_dir = "$top_dir/hitdr/tex"; }
        else {die "Cannot find target file: $target_tex\n";}
    }

    $full_target_tex = "$tex_dir/$target_tex";
    print "\n",'Building: ',"$full_target_tex\n\n";
# die "End debug";

# Define PATH of places to find other tex files, figures, bibliography stuff
# For now, only look in a single tree (means e.g. CTDR pictures are not exposed to PTDR)
# Revisit this if it looks likely to be needed.


   $tex_path = join($ps,$tex_dir,"$cur_dir/tex");
   $fig_path = join($ps,"$tex_dir/../fig","$tex_dir/../../fig","$tex_dir/../../../fig");
   $common_path = join($ps,"$gen_dir","$tmp_dir","$cur_dir","$cur_dir/..");



# Define directories to be searched by LaTeX, including one where script was invoked
# Note that it will revert automatically to its original value when script completes

$ENV{TEXINPUTS} = join($ps,$tex_path,$fig_path,$common_path,$ENV{TEXINPUTS});
$ENV{TEXPSHEADERS} = $ENV{TEXINPUTS}; # This is required by \includegraphics when using pdftex

# Set up temporary area and create input LaTeX file (boilerplate + target file)

    -e $tmp_dir || mkdir ($tmp_dir,0755) || die "Failed to create temporary output directory";

    my $temp_stem = $target;
    if ($style =~ 'pas')
    {
        $temp_stem =~ s/_/\-/g; # convert underscores to dashes
    }
    $temp_stem = "$tmp_dir/$temp_stem".'_temp';
    my $temp_tex = "$temp_stem".'.tex';

    unlink($temp_tex);
    if ($style !~ 'tdr') { #must be a note of some sort
         &myrep( "$gen_dir/skeleton_start.tex", "$temp_tex", ",tdr]", ",$style]" ) ;
   }
    else {
        &mycat( "$gen_dir/skeleton_start.tex", $temp_tex );
    }
    if (!$draft)
    {
        # use final as the option to avoid a clash with the common LaTeX usage.
        &myrep("$temp_tex","$temp_tex","]{cms-tdr}",",final]{cms-tdr}");
    }
    my $authorfilename;
    if ($arxiv || ($style =~ 'cmspaper' && ! $draft))
    {
        # use collab option to include footnote to collaboration listing
        $authorfilename = &myCollab($temp_tex);
        if ($authorfilename)
        {
            &myrep("$temp_tex","$temp_tex","]{cms-tdr}",",collab]{cms-tdr}");
        }
        else
        {
            $arxiv = 0;
        }
    }
    my $contactAddress;
    if ($style =~ 'pas')
    {
        @tmp = split('/',$tex_dir);
        my $PAS_name = @tmp[$#tmp];
        $PAS_name =~ s/_/\-/g; # convert underscores to dashes
        @tmp = split('-',$PAS_name);
        # generate contact address from PAS type
        my $PAS_type = @tmp[0];
        my %PAS_types = (
          BPH => "cms-pag-conveners-bphysics",
          BTV => "cms-pog-conveners-btag",
          EGM => "cms-pog-conveners-egamma",
          EWK => "cms-pag-conveners-ewk",
          EXO => "cms-pag-conveners-exotica",
          DIF => "cms-pag-conveners-fwd",
          FWD => "cms-pag-conveners-fwd",
          GEN => "cms-pag-conveners-generators",
          HIG => "cms-pag-conveners-higgs",
          HIN => "cms-pag-conveners-heavyions",
          JME => "cms-pog-conveners-jetmet",
          MUO => "cms-pog-conveners-muons",
          PFT => "cms-pog-conveners-pflowtau",
          QCD => "cms-pag-conveners-qcd",
          SBM => "cms-pag-conveners-exotica",
          SUS => "cms-pag-conveners-susy",
          TOP => "cms-pag-conveners-top",
          TRK => "cms-pog-conveners-tracking",
          CFT => "cms-craft-papers");
        $contactAddress = $PAS_types{$PAS_type};
        $contactAddress .= '@cern.ch';
        my $toAddress="\\href{mailto:".$contactAddress."?subject=".$PAS_name."}{Contact: ".$contactAddress."}";

        &myrep("$temp_tex","$temp_tex","begin{document}","begin{document}\\cmsNoteHeader{$PAS_name}\\cmsNoteContact{$toAddress}");
    }
    if ($style =~ 'cmspaper')
    {
         @tmp = split('/',$tex_dir);
         my $paperTag = @tmp[$#tmp];
         &myrep("$temp_tex","$temp_tex","begin{document}","begin{document}\\cmsNoteHeader{$paperTag}");
    }


#
# get the definitions.tex file from the tree you are in
#

    if( -e "$tex_dir/definitions.tex") { &mycat( "$tex_dir/definitions.tex", $temp_tex) ; }
    if( -e "$tex_dir/../definitions.tex") { &mycat( "$tex_dir/../definitions.tex", $temp_tex) ; }
    if( -e "$tex_dir/../../definitions.tex") { &mycat( "$tex_dir/../../definitions.tex", $temp_tex) ; }
    if( -e "$tex_dir/../../../definitions.tex") { &mycat( "$tex_dir/../../../definitions.tex", $temp_tex) ; }
    if( -e "$tex_dir/../../../../definitions.tex") { &mycat( "$tex_dir/../../../../definitions.tex", $temp_tex) ; }
#
# This is general definitions file - it uses \providecommand so definitions can
# be overridden just by defining them in one of the above definitions.tex files
#
    if( -e "$gen_dir/definitions.tex" && ($gen_dir ne $tex_dir) ) { &mycat("$gen_dir/definitions.tex", $temp_tex) ; }

    &mycat( $full_target_tex, $temp_tex);
    if ($arxiv)
    {
        open(OUTF, ">>", $temp_tex) || die("can't open outputfile: $!");
        print OUTF "\\cleardoublepage\\appendix\\section{The CMS Collaboration \\label{app:collab}}\\input{$authorfilename}\n";
        close(OUTF);
    }
    &mycat( "$gen_dir/skeleton_end.tex", $temp_tex);

# Set up temporary bibliography style and DB files

    my $temp_bst = "$tmp_dir/auto_generated.bst"; # Note: this is referred to explicitly from latex
    my $temp_bib = "$tmp_dir/auto_generated.bib"; # Note: this is referred to explicitly from latex

    unlink($temp_bst);
    unlink($temp_bib);

    copy("$gen_dir/lucas_unsrt.bst", $temp_bst);

    &mycat(bsd_glob("$tex_dir/*.bib"), bsd_glob("$tex_dir/../bib/*.bib"), bsd_glob("$tex_dir/../../bib/*.bib"), $temp_bib);


# various output log and error files; double quotes allow spaces in paths
    $temp_texq = '"'.$temp_tex.'"';
    $temp_stemq = '"'.$temp_stem.'"';
    $temp_pdfout = $temp_stem.'.pdftex_out';
    $temp_pdfoutq = '"'.$temp_pdfout.'"';
    $temp_pdferr = $temp_stem.'.err';
    $temp_pdferrq = '"'.$temp_pdferr.'"';
    $temp_bbl = $temp_stem.'.bbl';
    $temp_bibout = $temp_stem.'_bib.out';
    $temp_biboutq = '"'.$temp_bibout.'"';
    $temp_biberr = $temp_stem.'_bib.err';
    $temp_biberrq = '"'.$temp_biberr.'"';
    $temp_pdf = $temp_stem.'.pdf';
    $temp_pdflog = $temp_stem.'.log';

 # Now run latex, build table of contents, index, etc. and create dvi/PS/etc. files
    if ($^O eq "MSWin32")
    {
        my $orig_dir = Cwd::abs_path;
        chdir($tmp_dir);
        my $dirstring;
        my $files = $ENV{TEXINPUTS};
        $files =~ s/\//\\/g; # replace forward slashes with back slashes
        foreach my $dir (split($ps,$files)) {
            if (-e $dir) {$dirstring .= "-include-directory=".'"'.$dir.'" '};
            }
        if ( !$verbose )
        {
          print ("First pass TeXing file: $temp_texq\n");
          system ("pdflatex -interaction=batchmode $dirstring $temp_texq 1> NUL 2> NUL");
          print ("BibTeXing file: $temp_stem\n");
          system ("bibtex $dirstring $temp_stemq 1> $temp_biboutq 2> $temp_biberrq");
          print ("2nd pass TeXing file: $temp_texq\n");
          system ("pdflatex -interaction=batchmode $dirstring $temp_texq 1> NUL 2> NUL");
          print ("final (3rd pass) TeXing file: $temp_texq\n");
          system ("pdflatex -interaction=batchmode $dirstring $temp_texq 1> $temp_pdfoutq 2> $temp_pdferrq ");
        }
        else
        {
          print ("First pass TeXing file: $temp_texq\n");
          system ("pdflatex $dirstring $temp_texq");
          print ("BibTeXing file: $temp_stem\n");
          system ("bibtex $dirstring $temp_stemq");
          print ("2nd pass TeXing file: $temp_texq\n");
          system ("pdflatex $dirstring $temp_texq");
          print ("final (3rd pass) TeXing file: $temp_texq\n");
          system ("pdflatex $dirstring $temp_texq");
        }
        chdir( $orig_dir);
    }
    else
    {
        # check for certified CMS version of tex
        my $TeXversion;
        my $baseTeXversion = "3.141592-1.21a-2.2";
        if ( `pdftex -version` =~ /pdfeTeX\s*(\S*)/ ) {$TeXversion=$1};
        if ( -e '/afs/cern.ch/cms/external/tex/bin/i686-pc-linux-gnu/pdftex' )
        {
          if ( `/afs/cern.ch/cms/external/tex/bin/i686-pc-linux-gnu/pdftex -version` =~ /pdfeTeX\s*(\S*)/ ) {$baseTeXversion=$1};
          if ($TeXversion != $baseTeXversion)
          {
            $ENV{'PATH'} = '/afs/cern.ch/cms/external/tex/bin/i686-pc-linux-gnu:'.$ENV{'PATH'};
          }
        }
        elsif ($TeXversion != $baseTeXversion)
        {
          print "Using non-standard version of pdftex: ",`which pdftex`," ",`pdftex -version`,"\n";
        }
        chdir ($tmp_dir);
        if ( !$verbose )
        {
          print ("\n===============================================================\n");
          print ("First pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex -interaction=batchmode $temp_tex 1> /dev/null 2> /dev/null ");
          print ("\n===============================================================\n");
          print ("BibTeXing file: $temp_texq\n\n");
# system ( "bibtex $temp_stem 1> $temp_biboutq 2> $temp_biberrq ");
          system ( "bibtex $temp_stem ");
          print ("\n===============================================================\n");
          print ("Second pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex -interaction=batchmode $temp_tex 1> /dev/null 2> /dev/null ");
          print ("\n===============================================================\n");
          print ("Final (third) pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex -interaction=batchmode $temp_tex 1> $temp_pdfoutq 2> $temp_pdferrq ");
        }
        else
        {
          print ("\n===============================================================\n");
          print ("First pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex $temp_tex");
          print ("\n===============================================================\n");
          print ("BibTeXing file: $temp_texq\n\n");
          system ( "bibtex $temp_stem");
          print ("\n===============================================================\n");
          print ("Second pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex $temp_tex");
          print ("\n===============================================================\n");
          print ("Final (third) pass TeXing file: $temp_texq\n\n");
          system ( "pdflatex $temp_tex");
        }
    }

    if ( !$verbose )
    {
      print "\n-------------------------------------------------------------------\n\n",
      "PdfLaTeX errors (filtered):\n\n";
      open (LOGFILE, $temp_pdflog) || die ("can't open the log file: $!");
      $/ = "\n\n"; # reset EOR... most error messages are terminated by a blank line, so let's use it. (This misses: "! Emergency stop" and "*** (job aborted ")
      while ( <LOGFILE> ) {
        print if (/! |Missing character|Warning:|Error:|Fatal|Undefined|runaway|Runaway|pdftex Warning|pdfTeX warning/ && !/Float|float|Font Warning|weird|found\s+pdf\s+version\s+<1.5>|multiply\s/);
        }
      close (LOGFILE);
    }

    print "\n-------------------------------------------------------------------\n",
          "Output directory: $tmp_dir\n";
    print "-------------------------------------------------------------------\n", "Output Log files:\n";
    print "$temp_pdflog\n" if -e $temp_pdflog;
    print "$temp_pdfout\n" if -e $temp_pdfout;
    print "$temp_pdferr\n" if -e $temp_pdferr;
    print "$temp_bibout\n" if -e $temp_bibout;
    print "$temp_biberr\n" if -e $temp_biberr;

    print "-------------------------------------------------------------------\n",
          "Output PDF file:";
    print " $temp_pdf\n" if -e $temp_pdf;
    print "-------------------------------------------------------------------\n";

    if ( ($style =~ 'pas' || $style =~ 'cmspaper') && !$upload)
    {
        #strip out title(s)
        my $title = '';
        my $author = '';
        open(FILE, $temp_tex) || die("can't open TeX file $temp_tex: $!");
        $_ .= do { local( $/ ); <FILE> }; #grab entire content!
        close(FILE);
        # extract metadata
        m/\\hypersetup(.*)/s; # find hypersetup
        my $xtract = $1;
        my $substring = extract_bracketed($xtract,'{}');
        if ($substring =~ m/pdftitle\s*=\s*\{(.*?)\}/s) #use non-greedy matching
        {
            $title = $1;
            print "\n", ">>> PDF TITLE: ",$title,"\n";
        }
        else
        {
            print "Cannot find title in metadata\n";
        }
        if ($substring =~ m/pdfauthor\s*=\s*\{(.*?)\}/s)
        {   $author = $1;
            print "\n", ">>> PDF AUTH : ",$author,"\n";
        }

    }
    if ( $export ) {
        my @exportFiles = ($temp_tex, $temp_bbl, "$gen_dir/cms-tdr.cls", "$gen_dir/CMS-bw-logo.pdf",
        "$gen_dir/hypernat.sty", "$gen_dir/topcapt.sty", "$gen_dir/ptdr-definitions.tex");
        if ($arxiv)
        {
            push(@exportFiles,"$tmp_dir/authorlist.tex")
        }
        else
        {
            push(@exportFiles,$temp_bib, $temp_bst);
        }
        push(@exportFiles,$target);
        &export_files(@exportFiles);
    }
    # wrap for deposition
    if ( $wrap ) {
        &wrap_files($full_target_tex, $temp_pdf, $temp_pdflog, $tex_dir, $contactAddress);
    }
}
#############################################################################
sub wrap_files {
# will eventually move most of this into makeManifest: for now just "?smart?" wrapper
    my $full_target_tex = shift;
    $tmp_out =~ s+\\+/+g; #unix-style filepath
    my $pdfFile = shift;
    my $pdfOut = $pdfFile;
    $pdfOut =~ s/_temp.pdf$/-$style.pdf/; # TODO use style
    $pdfOut = basename($pdfOut);
    my $logFile = shift;
    my $baseDir = shift;
    my @parts = split m+/+, $baseDir;
    my $noteCode = $parts[$#parts];
    if ($style =~ 'pas')
    {
        push(@exportFiles,$target);
        $noteCode =~ s/_/\-/g; # convert underscores to dashes to accommodate old style
    }
    my $contactAddress = shift;
    my $base_out = "/afs/cern.ch/cms/PAS/test/";
    my $tmp_out = $base_out.$noteCode; #means must have afs access...
    if (! -d $tmp_out)
    {
       if ( ! mkdir ($tmp_out) )
       {
           print "Making temporary directory for --wrap\n";
           $tmp_out = tempdir() or die;
       }
    }
    else
    { #delete contents
        unlink(bsd_glob("$tmp_out/*"));
    }
    copy($pdfFile, "$base_out/$pdfOut") or warn "Can't copy $pdfFile\n"; # keep this copy for backwards compatibility
    copy($pdfFile, "$tmp_out/$pdfOut") or warn "Can't copy $pdfFile\n"; # and this one for the upload
    local @ARGV;
    if ($reload)
    {
        @ARGV = ("--tex", $full_target_tex, "--doc", $pdfOut, "--style", "$style", "--baseDir", $baseDir, "--outDir", $tmp_out, "--logFile", $logFile, "--contactAddress", $contactAddress, "--updateRecord", $reload);
    }
    else
    {
        @ARGV = ("--tex", $full_target_tex, "--doc", $pdfOut, "--style", "$style", "--baseDir", $baseDir, "--outDir", $tmp_out, "--logFile", $logFile, "--contactAddress", $contactAddress);
    }
    eval { require "$gen_dir/makeManifest.pl" };

    if (!$preview)
    {
        # not all systems have Archive, so test
        my $useArchive = eval {require Archive::Zip};
        my $archive;
        if ($useArchive)
        {
            $archive = "$tmp_dir/submit.zip";
            my $zip = Archive::Zip->new();
            $zip->addTree("$tmp_out");
            my $status = $zip->writeToFileNamed("$archive");
            if ( $status != AZ_OK )
            {
                print "Can't make archive file\n";
            }
        }
        else
        {
            my $orig_dir = Cwd::abs_path;
            chdir($tmp_out);
            $archive = "$tmp_dir/submit.tgz";
            system("tar --gzip --create --file $archive *")==0 or die "Error creating tar file. Sorry";
             chdir($orig_dir);
        }
        if ($verbose) {print "Created archive file $archive.\n"};
        # now submit to cds
        if ($upload) {
            my $uploadMode = $reload ? '-r' : '-i';
            my $curlCmd = "curl -F 'file=@/afs/cern.ch/cms/PAS/test/$noteCode/manifest.xml' -F 'mode=$uploadMode' http://cdsweb.cern.ch/webupload.py -A invenio_webupload";
            print "Uploading to CDS using command: $curlCmd\n";
            system($curlCmd);
            if (!$?==0) { print "Error uploading file to cds.\n"; }
            if ($verbose) { print "Uploaded manifest file to server.\n"; }
        }
    }


}
#############################################################################
sub export_files {
    my @tocopy = (@_);
    my $exp_name = pop(@tocopy); # pop off target name
    my $exp_dir = "export";
    -d $exp_dir || mkdir ($exp_dir,0755) || die "Failed to create temporary export directory";
    chdir ($exp_dir);
    my $current_dir = getcwd();
    print "\nCreating export directory $current_dir\n";
    if ($style !~ 'tdr')
    {
         copy("$gen_dir/cms_draft_$style.pdf", "cms_draft_$style.pdf");
         copy("$gen_dir/cms_$style.pdf", "cms_$style.pdf");
         copy("$gen_dir/pdfdraftcopy.sty","pdfdraftcopy.sty");
         copy("$gen_dir/BigDraft.pdf","BigDraft.pdf");
    }
    recursive_copy($tex_dir,$current_dir,1);
    my @figdirs = split(/$ps/,join($ps,$tex_path));
    for (@figdirs)
    {
      my @in = bsd_glob($_."/*.{pdf,jpg,png,jpeg,eps}");
      for (@in)
      {
        (my $x, my $y, my $file) = File::Spec->splitpath($_);
        copy($_,$file);
      }
    }
    @figdirs = split(/$ps/,join(ps,$fig_path));
    for (@figdirs)
    {
        if (-d $_)
        {
            recursive_copy($_,$current_dir,1);
        }
    }
    for (@tocopy)
    {
        (my $x, my $y, my $file) = File::Spec->splitpath($_);
        copy($_,$file);
    }
    if ($^O eq "MSWin32") {
        print "Export directory ready.\n"
    }
    else {
        chdir ("..");
        system("tar --gzip --create --file $exp_name.tgz $exp_dir")==0 or die "Error creating tar file. Sorry";
        if (-e "$exp_name.tgz") {
            unlink(bsd_glob("$exp_dir/*"));
            rmdir($exp_dir);
            my $exp_path = Cwd::abs_path;
            print "Export tarball $exp_path/$exp_name.tgz is ready.\n";
            if ($verbose) {
                print "Contents of tar archive:\n";
                system("tar --gzip --list --file export.tgz");
            }
        }
        else {
          print "Sorry, something has prevented creation of the tarball.\n";
        }
    }
}
#############################################################################
sub recursive_copy {
# recursively copy a directory tree (not including CVS directories)
# arguments: from directory, to directory, top dir?
  my $from = abs_path(shift);
  my $to = abs_path(shift);
  my $top = shift;
  -d $from or die "Recursive copy: From directory \"$from\" is not a directory";
  -d $to or die "Recursive copy: To directory \"$to\" is not a directory";
  (my $volume, my $directories, my $file) = File::Spec->splitpath( $from );
  my $tofrom = 0;
  if ($top)
  {
    $tofrom = $to;
  }
  else
  {
    $tofrom = $to."/".$file;
    mkdir $tofrom;
  }
  my @files = bsd_glob($from."/*");
  for (@files)
  {
      if (-f $_)
      {
        (my $volume, my $directories, my $file) = File::Spec->splitpath( $from );
        copy($_,$tofrom);
      }
      elsif (-d $_)
      {
        if ($_ !~ /^.*CVS$/)
        {
            recursive_copy($_,$tofrom,0);
        }
      }
  }
}



#############################################################################
sub clean {
    print "\nRemoving all contents of temporary directory: $tmp_dir\n";
    unlink(bsd_glob("$tmp_dir/*"));
    rmdir($tmp_dir);
}



#############################################################################
sub veryclean {
# could be less crude but good enough for now

    print "\nCleaning everything...\n";
    &clean();

    print "\nDeleting emacs backup files...\n";
    unlink (bsd_glob ("$top_dir/*.*~"));
    unlink (bsd_glob ("$top_dir/*/*.*~"));
    unlink (bsd_glob ("$top_dir/*/*/*.*~"));
    unlink (bsd_glob ("$top_dir/*/*/*/*.*~"));
    unlink (bsd_glob ("$top_dir/*/*/*/*/*.*~"));

    print "\nDeleting nedit backup files...\n";
    unlink (bsd_glob ("$top_dir/*.*.bak"));
    unlink (bsd_glob ("$top_dir/*/*.*.bak"));
    unlink (bsd_glob ("$top_dir/*/*/*.*.bak"));
    unlink (bsd_glob ("$top_dir/*/*/*/*.*.bak"));
    unlink (bsd_glob ("$top_dir/*/*/*/*/*.*.bak"));

    print "\nDeleting all dvi, toc, lof, etc. files...\n";

    unlink (bsd_glob ("$top_dir/*/*.ind"));
    unlink (bsd_glob ("$top_dir/*/*.ilg"));
    unlink (bsd_glob ("$top_dir/*/*.aux"));
    unlink (bsd_glob ("$top_dir/*/*.aidx"));
    unlink (bsd_glob ("$top_dir/*/*.idx"));
    unlink (bsd_glob ("$top_dir/*/*.lof"));
    unlink (bsd_glob ("$top_dir/*/*.lot"));
    unlink (bsd_glob ("$top_dir/*/*.log"));
    unlink (bsd_glob ("$top_dir/*/*.dvi"));
    unlink (bsd_glob ("$top_dir/*/*.toc"));
    unlink (bsd_glob ("$top_dir/*/*.blg"));
    unlink (bsd_glob ("$top_dir/*/*.bbl"));

}


#############################################################################
sub runtime {
#
# Changes environment variables *OUTSIDE* scope of the script
# (using ENV is only within scope of script).
#
# To use this, you need to use eval (see help) to "invoke" the
# env setting commands which are printed out (see below)
#
    my $shell = $_[0] || "-csh";

# Add bin directory to PATH (but only if it's not there already)

# print ('$PATH = ',"$ENV{PATH} \n");
# print ('$bin_dir = ',"$bin_dir \n");

    if ($ENV{PATH} !~ /$bin_dir/){
        print ("\n");

        if ($shell eq "-csh" || $shell eq "-tcsh") {
            print "echo Prepending PATH with: $bin_dir;",
                  "setenv PATH $bin_dir".":$ENV{PATH}\n";
        }
        elsif($shell eq "-sh" || $shell eq "-ksh"){
            print "echo Prepending PATH with: $bin_dir;",
                  'PATH="',"$bin_dir".":$ENV{PATH}",'";',
                  "export PATH\n";
        }
        else{
            die "Unknown shell option: $shell\n\n";
        }
    }
}

#############################################################################
sub test {

    print "\nExecuting tdr test\n-------------------\n\n";

    print '$cur_dir = ',"$cur_dir\n\n";
    print '$top_dir = ',"$top_dir\n";
    print '$bin_dir = ',"$bin_dir\n";
    print '$gen_dir = ',"$gen_dir\n";
    print '$tex_dir = ',"$tex_dir\n";
    print '$fig_path = ',"$fig_path\n";
    print '$tmp_dir = ',"$tmp_dir\n\n";

    print '$ENV{TEXINPUTS} = ',"$ENV{TEXINPUTS}\n\n";

}



#############################################################################
sub full_path {
#
# Get full directory path from relative one and context
#
  my $file = shift;
  my $current_dir = shift || &cwd();
# print ("full_dir: file= $file, current_dir=$current_dir\n");
  if("$file" eq "")
       {return "";}
  elsif($file=~/^~\/(.*)/)
       {$file="$ENV{HOME}/$1"; }
  elsif($file=~/^~[^\/](.+)\/(.*)/)
       {$file=`dirname ~$1`;
        chomp $file;
        $file="$file/$2";}
  elsif($file=~/^~[^\/](.+)$/)
       {$file=`dirname ~$1`;
        chomp $file;}
  elsif($file=~/^[^\/]/)
       {$file="${current_dir}/$file";}

  return &arrange_path($file);
}

#############################################################################
sub arrange_path {
  my $file=shift;
# print ("arrange_path: file = $file\n");
  if("$file" eq "") {return "";}

  while($file=~/(.*)\/\.\/(.*)/){$file="$1/$2";}

  if($file=~/(.*)\/\.$/){$file="$1";}

  while($file=~/(.*?)\/\.\.\/(.*)/){
     $file=`dirname $1`;
     chomp $file;
     $file="$file/$2";
  }
  while($file=~/(.*?)\/\.\.$/){
     $file=`dirname $1`;
     chomp $file;
  }
  while($file=~/(.*)\/\/(.*)/) {$file="$1/$2";}
# print("arrange_path, returning: $file\n");

  return $file;

}
#############################################################################
sub mycat
{
# acts as cat.
# default is append (see second arg in the open command below)
   my (@args) = @_;
   open(OUTF, ">>", pop(@args)) || die("can't open outputfile: $!");
   FILE: foreach (@args) {

      open(FILE, $_) || ((warn "Can't open file $_\n"), next FILE);

      while (<FILE>) {
         print OUTF;
      }
      close(FILE);
   }
   close(OUTF);
}
#############################################################################
sub myrep { # replace in file; equivalent to perl -p -e 's/xxx/yyy'
   my $infile = shift;
   my $outfile = shift;
   my $in = shift;
   my $out = shift;
   my $replace = ($infile eq $outfile);
   my $outf, $tmpf;
   open(INF, $infile) or die("can't open inputfile: $!");
   if ($replace)
   {
     ($outf, $tmpf) = tempfile() or die("can't open temp file!");
   }
   else
   {
     open($outf, ">", $outfile) or die("can't open outputfile: $!");
   }
   while (<INF>) {
         s/$in/$out/;
         print $outf "$_";
   }
   close($outf);
   close(INF);
   if ($replace)
   {
     copy($tmpf,$outfile);
     unlink($tmpf);

   }

}
#############################################################################
sub myls { # acts as a sort of ls
# expects the directory as the first argument and the bsd_glob pattern as the (optional) second argument
  my $dir = shift;
  my $ext = shift;
  if ($ext eq '') {$ext = '*';}
  my @list = bsd_glob($dir.'/'.$ext);
  for (@list) {
# s|^$dir/||;
    print $_,"\n";
    }
}
#############################################################################
sub myCollab {
# Adds the appendix with the collaboration list
# default is append (see second arg in the open command below)
   my (@args) = @_;
   $_ = @_[0];
   /^(.*\/tmp\/)(.*)_temp.tex/; #extract the tag
   my $tag = $2;
#   my $tag = 'EWK-09-001'; # known to exist: for debugging
   my $tagfile = 'authorlist.tex';
   my $authorfile = $1.$tagfile;
   my $url = 'http://cern.ch/cms-secr/Documents/authorListCMS/'."$tag".'-authorlist.tex';
   my $body = &get_url ($url);
   if (!defined $body)
   {
        print "::: Authorlist for $tag not found! :::\n::: Bailing out :::\n";
        return 0; #should die?
   }
   $body =~ s/,/, /g; #allow normal spacing and line breaking
   # save the authorlist
   open(OUTF, ">", $authorfile) || die("Can't open outputfile: $!");
   print OUTF $body;
   close(OUTF);
   return $tagfile;
   # include it in processing
}
#############################################################################
sub get_url{
    my ($url) = @_;

    use strict;
    use warnings;
    use LWP::Simple;
    return my $doc = get $url;
    }

